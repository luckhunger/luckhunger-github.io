---
layout: default
title: 예외(exception)
parent: 자바
nav_order: 10
---
## 목차
{: .no_toc .text-delta }

1. TOC
{:toc}
---

# **예외**
1. JVM(자바 가상 머신)이 감지할 수 있는 오류를 말한다.
2. 에러는 컴퓨터 하드웨어의 오동작 또는 고장으로 인해 발생하므로 JVM 위에서 실행되는 프로그램을 아무리 견고하게 만들어도 결국 실행 불능이 된다.

---

## **특징**
1. 예외가 발생하면 예외의 종류에 따라 예외를 관리하는 클래스가 자동으로 객체화된다.
2. 실행 과정 중에 예외가 발생하면 그 즉시 프로그램이 중단되고 JVM 이 발생한 예외의 종류를 메시지로 출력한다.
3. 예외처리 구문을 미리 설정해 놓으면 실행 과정 중에 예외가 발생하더라도 프로그램이 중단되지 않고 원하는 방향으로 진행시킬 수 있다.

---

## **종류**
예외의 이름은 예외를 관리하는 클래스 이름이기도 하다.

|IOException|입출력 과정에서 일어나는 문제로 발생하는 예외|
|NumberFormatException|숫자가 나와야하는 자리에 문자가 나오는 경우에 발생하는 예외|
|NoSuchMethodException|메소드를 찾을 수 없을 경우 발생하는 예외|
|interruptedException|인터럽트로 인해 발생하는 예외|
|classNotFoundException|클래스를 찾을 수 없는 경우 발생하는 예외|
|ArithmeticException|숫자를 0으로 나눌 경우 발생하는 예외|
|ArrayIndexOutOfBoundsException|지정한 배열의 크기를 넘어서 데이터를 저장할 경우 발생하는 예외|
|NullPointException|객체 생성 없이 속성변수, 멤버 메소드를 호출할 경우 발생하는 예외|
|ClassCastException|클래스간에 형변환(casting)이 불가능한 경우 발생하는 예외|
|IllegalArgumentException|잘못된 argument 를 메소드로 넘길 경우 발생하는 예외|
|NegativeArraySizeException|배열의 크기를 음수리 지정할 경우 발생하는 예외|
|EmptyStackException|빈 스택에 데이터를 찾고자 하는 경우 발생하는 예외|
|NoSuchElementException|존재하지 않은 데이터를 찾고자 하는 경우 발생하는 예외|
|SecurityException|제한된 자원에 접근하고자 하는 경우 발생하는 예외|

---

## **예외를 관리하는 클래스의 상속도**

|Object(최상위 클래스)|
| |
|Throwable|
| |
|Exception(예외 관리 클래스)|
|RuntimeException|
||
|기타 예외 관련 메소드들|

---

# **예외 처리 구문(try-catch-finally)**
> 1. 예외가 발생하면 개발자가 원하는 방향으로 프로그램들이 진행되도록 설정하는 구문이다.
> 2. 몇 가지 예외는 무조건 의무적으로 예외처리 구문을 설정해야만 컴파일이 가능하다.
> 3. 예외처리 구문을 설정하지 않으면 예외 발생 시 치명적인 영향을 받을 수 있다.
>    + IOExcption 예외가 이에 해당한다.

---

## **예외 처리 구문 형식**

```java
~ 메소드명(~) {
    ~
    try {
        예외 발생 가능 실행문;    
    } catch(예외관리 클래스명 매개변수) {
        예외 발생 시 실행문;    
    } finally {
        필수 처리 실행문;    
    }
    기타 실행문;
}

```

---

## **예외 처리 실행 순서**
### **try 구문에서 예외가 발생할 경우**
> 1. 예외 발생 가능 실행문 실행 도중 예외 발생
> 2. 예외 관리 객체 실행
> 3. catch(예외관리클래스명.매개변수) {~} 구문을 호출하여 예외 발생 시 실행문 실행
>    + 매개변수에 예외처리 객체의 메모리 위치 주소값이 들어간다.
>    + 메소드 형태와 비슷하다.
> 4. 필수 처리 실행문 수행
> 5. 기타 실행문 실행
>    + <font color='#ff0000'>※ try / catch 구문에 `return` 이 나오면 실행하지 않는다.(finally 까지만 실행한다.)</font>
>    + finally 가 return 보다 우선권을 가진다. 그래서 try / catch 에 return 이 있어도 finally 를 실행한다.

---

### **try 구문에서 예외가 발생하지 않을 경우**
> 1. 예외 발생 가능 실행문 실행
> 2. 필수 처리 실행문 실행
>    + finally 구문은 생략이 가능하다.
> 3. 기타 실행문 실행 

---

## **예외 처리 구문의 특징**
> 1. 발생 가능 예외가 2개 이상이면 2개 이상의 catch 구문을 설정할 수 있다.
> 2. catch 구문이 2개 이상일 경우 아래로 갈수록 catch 구문의 매개변수 자료형이 위보다는 아래가 부모 예외 처리 클래스이어야 한다. 즉, `먼저` 나오는 구문이 반드시 `자식클래스`이다.
> 3. `finally` 구문은 필요에 따라 `생략`할 수 있다.
> 4. 데이터베이스를 연결하여 작업하는 경우 `finally` 구문을 꼭 사용하는 것이 좋다.
>    + DB 를 연결한 후 작업 도중에 예외가 발생하거나 작업이 완료된 후 반드시 DB 연결을 끊어야하므로 finally 구문 안에 DB 연결을 끊는 실행문을 삽입한다.
> 5. <font color='#ff0000'>※  try 구문 또는 catch 구문의 실행 도중 `return` 이 나오면 바로 `finally` 블록으로 이동하여 finally 블록을 실행한 후 메소드가 `중단`된다.</font>
> 6. <font color='#ff0000'>※  try 구문 또는 catch 구문의 실행 도중 `System.exit(0)` 가 나오거나 시스템이 중단되면 finally 블록으로 이동 없이 바로 메소드가 `중단`된다.</font>

---

# **📌 throws 구문**
> 1. 예외가 발생할 경우 예외 발생 구문을 호출한 곳으로 예외를 던질 때 사용한다.
> 2. 코드가 너무 길어서 메소드로 따로 빼서 사용한다.

---

## **throws 구문 형식**

```java
~ 메소드명1(~) {
    ~
    try {
        메소드명2(~);    
    } catch(예외관리클래스명 매개변수) {
        예외 발생 시 실행문;    
    } finally {
        필수 처리 실행문;    
    }
    기타 실행문;
}

// 예외 발생 시 호출한 클래스에서 처리하도록 하는 메소드2 선언
~ 메소드명2(~) throws 예외관리 클래스명 {
    예외 발생 가능 실행문;    
}

```

---

## **예외 처리 실행 순서**
> 1. 예외 처리 구문 없는 main() 메소드에 `throws` 를 붙인 상태에서 예외가 발생하면 JVM 이 실행을 중단하고 예외를 처리한다.
> 2. 이 때 예외 처리한 `try-catch-finally` 구문의 기능이 아닌 예외 메시지를 출력하는 정도이다.

---

### **try 구문에서 예외가 발생할 경우**
> 1. 메소드명2(~) 호출
> 2. 예외 발생 가능 실행문을 실행하는 도중 예외 발생
> 3. 예외 관리 객체 생성
> 4. `throws` 에 의해 메소드명2(~) 호출한 곳으로 예외관리 객체를 던진다.
> 5. `catch() {~}` 구문을 호출하여 예외 발생 시 실행문을 실행.
> 6. 필수 처리 실행문 실행.
> 7. 기타 실행문 실행.

---

### **try 구문에서 예외가 발생하지 않은 경우**
> 1. 메소드명2(~) 호출
> 2. 예외 발생 가능 실행문 실행
> 3. 필수 처리 실행문 실행
> 4. 기타 실행문 실행

---
# **throw 구문**
코딩으로 직접 예외를 발생시킬 때 사용한다.

---
## **throw 구문 형식**

```java
~ 메소드명1(~) {
    ~
    try {
        if(조건식) {
            throw new 예외클래스명();
        }    
    } catch(예외관리클래스명 매개변수) {
        예외 발생 시 실행문;
    } finally {
        필수 처리 실행문; 
    }
    기타 실행문;
}

```

---
## **예외 처리 실행 순서**
### **try 구문에서 예외가 발생할 경우**
> 1. 조건식이 true 여서 `throw new 예외클래스명();` 이 실행되어 예외 관리 객체를 생성하고 예외가 발생했다고 JVM에게 알려준다.
> 2. catch(~){~} 구문을 호출하여 예외 발생 시 실행문 실행
> 3. 필수 처리 실행문 실행
> 4. 기타 실행문 실행

---

### **try 구문에서 예외가 발생하지 않은 경우**
> 1. 조건식이 false 여서 `throw new 예외관리클래스명();` 이 실행되지 않음
> 2. 필수 처리 실행문 실행
> 3. 기타 실행문 실행

---
# **사용자 정의 예외**
사용자가 임의의 예외를 만들고 그 예외를 정의한 클래스를 만들어 예외를 처리할 수 있다.

---
## **사용자 정의 예외 선언 형식**
> 1. 메소드 뒤에 throws 가 위치하면 메소드를 호출하고 예외가 발생했을 때, 발생한 곳으로 던져 처리하게 한다.
> 2. 메소드 왼쪽에 throw 가 위히차면 예외처리 클래스를 객체화한다.

---

# **인터럽트**
> 1. 현재 처리하고 있는 일 이외에 긴급하게 처리할 일이 발생했을 경우 컴퓨터 내의 장치나 프로그램으로부터 오는 신호이다.
> 2. 운영체계는 1개 이상의 인터럽트가 발생되면 인터럽트 간의 `우선순위`를 정하고 `스케쥴러`라는 프로그램이 우선 순위가 높아 다음번에 수행되어야 할 프로그램에게 `제어권`을 넘겨준다.
     >    + 일반적으로는 하드웨어적인 오류에 의해 발생되는 인터럽트가 최상위 우선순위를 가진다.
> 3. 오늘날 거의 모든 PC 나 대형 컴퓨터들이 인터럽트 기반의 시스템이다.
> 4. 일단 프로그램 내의 컴퓨터 명령문을 실행하면 더 이상 작업을 진행할 수 없거나 인터럽트 신호가 감지될 때 까지 명령문을 실행한다.

---

