---
layout: default
title: 상속(inheritance)
parent: 자바
nav_order: 7
---
## 목차
{: .no_toc .text-delta }

1. TOC
{:toc}
---

# **상속**
> 1. 클래스가 소유한 멤버(속성변수, 메소드 등)를 다른 클래스에게 그대로 물려주는 것을 말한다.
> 2. 상속해준 클래스를 `슈퍼클래스`, 상속받은 클래스를 `서브클래스`라고 한다.
> 3. Java API 에 정의된 모든 클래스는 기본적으로 Object 클래스로부터 상속되어 파생된 클래스들이다.
> 4. 개발자가 만든 클래스가 어떤 클래스도 상속하지 않도록 정의했더라도 컴파일 시 자바는 내부적으로 Object 클래스를 상속하도록 코드를 추가한다.
> 5. 자바에서 생성된 모든 클래스는 Object 클래스가 가지고 있는 변수와 메소드를 상속하여 그대로 사용할 수 있다.

---

## **상속 관계 설정 형식**

### **1. 슈퍼클래스**
```java
[public] [abstract | final] class 슈퍼클래스명 {
    
}
```
 
---

### **2. 서브클래스**
```java
[public] [abstract | final] class 서브클래스명 extends 슈퍼클래스명 {
    
}
```

---

### **3. final**
> 1. 자식이 없다는 의미이다.
> 2. 서브클래스에서는 사용이 가능하다.

---

### **상속의 이유**
> 1. 속성변수와 메소드를 공유하기 위해 사용한다.
> 2. 공유를 통한 자원낭비를 방지한다.

---

## **상속 장점**
> 1. 서브클래스는 슈퍼클래스의 멤버를 공유하므로 재사용성, 간결성, 프로그램 개발속도의 증가 등의 장점이 있다.
> 2. 상속을 이용하면 반복되는 코드를 줄일 수 있고 클래스간의 관계를 명백히 할 수 있다.
> 3. 계속 이어지는 상속으로 클래스는 계층적인 구조로 되어 전체 클래스를 보다 효율적으로 관리하고 사용할 수 있다.

---

## **상속 특징**
> 1. 슈퍼클래스는 1개 이상의 서브클래스를 가질 수 있다.
> 2. 서브클래스는 단 1개의 슈퍼클래스만 가질 수 있다.
>    + 만약 서브클래스 입장에서 슈퍼클래스가 2개 이상이고 슈퍼클래스들이 동일한 메소드를 가지고 있을 경우 서브클래스에서 해당 메소드를 호출 시에 어느 슈퍼클래스의 메소드를 호출해야하는지 혼란에 빠진다.
> 3. 서브클래스의 생성자 안의 첫 줄에는 반드시 슈퍼클래스의 생성자를 호출하는 `super(~)` 가 있어야 한다.
>    + 만약 `super(~)` 가 없다면 JVM이 컴파일 시에 자동으로 삽입한다.
>    + 즉, 서브클래스가 객체화되면 슈퍼클래스의 생성자 실행구문이 먼저 실행되고 난 후 서브클래스의 생성자 실행구문이 실행된다.
> 4. 서브클래스 영역에서 슈퍼클래스의 속성변수 또는 메소드를 호출할 수 있다.
>    + 예외로 `private` 가 붙으면 호출이 불가능하다.
> 5. <font color='#ff0000'>※ 서브클래스 객체화 후 속성변수 또는 메소드를 호출하면 먼저 서브클래스에서 찾고 난 후 없으면 슈퍼클래스에서 찾아 호출한다.</font>
>    + 단, `private` 가 슈퍼클래스의 호출 멤버에 붙으면 호출할 수 없다.
> 6. 서브클래스 영역에서 슈퍼클래스의 메소드를 재정의할 수 있다.
>    + 단 `final` 이 붙은 메소드는 불가능하고 `오버라이딩 규칙`에 맞게 재정의해야한다.

---

## **상속 관련 클래스의 객체화 형식, 메소드 / 속성변수의 호출 형식, 호출 가능 여부**

### **서브클래스**
<table>
    <tr>
        <td rowspan="6">서브클래스명 객참변수 = new 서브클래스 생성자명(~);</td>
        <td>메소드 / 속성변수 호출 형태</td>
        <td>호출가능 여부</td>
    </tr>
    <tr>
        <td>객참변수.서브클래스 고유메소드(~)</td>
        <td>O (단, private 가 없어야 함)</td>
    </tr>
    <tr>
        <td>객참변수.서브클래스 고유속성변수</td>
        <td>O (단, private 가 없어야 함)</td>
    </tr>
    <tr>
        <td>객참변수.재정의메소드(~)</td>
        <td>O</td>
    </tr>
    <tr>
        <td>객참변수.슈퍼클래스 고유메소드(~)</td>
        <td>O (단, private 가 없어야 함)</td>
    </tr>
    <tr>
        <td>객참변수.슈퍼클래스 고유속성변수(~)</td>
        <td>O (단, private 가 없어야 함)</td>
    </tr>

</table>

---

### **슈퍼클래스**
<table>
    <tr>
        <td rowspan="8">슈퍼클래스명 객참변수 = new 서브클래스 생성자명(~);</td>
        <td>메소드 / 속성변수 호출 형태</td>
        <td>호출가능 여부</td>
    </tr>
    <tr>
        <td>객참변수.슈퍼클래스 고유메소드(~)</td>
        <td>X</td>
    </tr>
    <tr>
        <td>객참변수.슈퍼클래스 고유속성변수</td>
        <td>X</td>
    </tr>
    <tr>
        <td>객참변수.재정의메소드(~)</td>
        <td>O</td>
    </tr>
    <tr>
        <td>객참변수.슈퍼클래스 고유메소드(~)</td>
        <td>O (단, private 가 없어야 함)</td>
    </tr>
    <tr>
        <td>객참변수.슈퍼클래스 고유속성변수(~)</td>
        <td>O (단, private 가 없어야 함)</td>
    </tr>
    <tr>
        <td>((서브클래스명.객참변수).서브클래스 고유메소드)</td>
        <td>O (단, private 가 없어야 함)</td>
    </tr>
    <tr>
        <td>((서브클래스명.객참변수).서브클래스 고유속성변수)</td>
        <td>O (단, private 가 없어야 함)</td>
    </tr>

</table>

---

# **📌 오버라이딩**
> <font color='#ff0000'>※ 슈퍼클래스가 소유한 메소드를 서브클래스에서 같은 메소드 이름으로 재정의하는 것을 말한다.</font>

---

## **오버라이딩 사용 이유**
> 1. 슈퍼클래스의 메소드를 서브클래스가 그대로 사용하기에 맞지 않아서 원하는 형태로 수정해 사용하기 위함이다.
> 2. 같은 메소드명으로 다른 기능의 메소드를 2개 이상 선언하여 사용함으로 다형성(polymorphism)을 가진다.


---

## **📌 메소드 오버라이딩 규칙**
> 1. 슈퍼클래스의 메소드에 `final` 또는 `priavate`가 없어야한다.
> 2. 리턴형, 메소드명, 매개변수, 매개변수의 개수, 매개변수의 자료형이 모두 같아야 한다.
> 3. 서브클래스의 접근지정자 범위는 슈퍼클래스의 접근지정자 범위보다 같거나 커야한다.

---

## **어노테이션**
> 1. `@` 는 여러 어노테이션 중 하나이다.
> 2. 클래스, 속성변수, 매개변수, 메소드 앞에 붙어 사용된다.
> 3. `@Override`는 무조건 오버라이딩 시도로 보고 규칙을 검사하여 에러 여부를 확인한다는 의미이다.

---

# **📌 super 예약어**
> 1. 서브클래스 내부에서 슈퍼클래스가 소유한 고유 멤버인 속성변수, 메소드, 생성자를 호출하기 위해 사용한다.
> 2. 서브 클래스의 생성자 안에 첫 줄에는 반드시 슈퍼클래스의 생성자를 호출하는 `super(~)`가 있어야 한다.
>    + 만약 `super(~)`가 없다면 JVM이 컴파일 시 자동으로 삽입한다.
> 3. <font color='#ff0000'>※ super(~)는 서브클래스의 생성자 안에서만 나오는 명령어이다. 서브클래스의 메소드 안에서 나올 수 없다.</font>
> 4. 나에게 있는 메소드나 필드를 찾지 말고 내 부모 클래스에 있는 필드나 메소드를 사용하라는 의미이다.

---

## **super 사용 형식**
>  
|형식|의미|
|---|-----|
|super.속성변수|서브클래스에서 슈퍼클래스의 `속성변수` 호출|
|super.메소드|서브클래스에서 슈퍼클래스의 `메소드` 호출|
|super(~)|서브클래스에서 슈퍼클래스의 `생성자` 호출|

---

# **📌 this 예약어**
> 1. 클래스가 소유한 고유 멤버인 속성변수, 메소드, 생성자를 지칭하거나 클래스가 객체화될 때 객체의 위치주소값을 말한다.
> 2. 지역변수 또는 매개변수와 속성변수의 변수명이 같을 경우 구분하기 위해 사용한다.
> 3. 부모 클래스와 자식 클래스의 속성변수, 메소드, 생성자의 이름이 같을 경우 구분하기 위해 사용한다.
> 4. <font color='#ff0000'>※ this(~)는 생성자 안에서만 나오는 명령어이다. 메소드 안에서 나올 수 없다.</font>

---

## **this 사용 형식**
> 
|형식|의미|
|---|-----|
|this.속성변수명|클래스의 고유멤버인 `속성변수` 호출|
|this.메소드명|클래스의 고유멤버인 `메소드` 호출|
|this(~)|클래스의 고유멤버인 `생성자` 호출|
|this|클래스가 객체화 될 경우 객체의 위치주소값|

---

# **추상클래스**
> 1. body가 없는 메소드를 한 개 이상 소유하고 있는 클래스를 말한다.
> 2. 조상 클래스 중에 body를 한 개 이상 소유하고 있고 이 메소드를 그 누구도 재정의하지 않은 상황을 가진 후손 클래스를 말한다.

---

## **추상클래스 형식**
```java
[public] abstract class 클래스명 {
    public | protected | default abstract 기본형 | 참조형 | void 추상메소드명([자료형 매개변수]);
}
```

---

## **추상클래스의 용도**
> 추상클래스를 상속받은 서브클래스는 추상클래스가 소유한 추상메소드를 재정의하여 사용함으로써 메소드의 작업 명세표 역할을 하며 공통된 작업의 규격을 만들 수 있다.

---

## **추상클래스의 특징**
> 1. 추상클래스 이름 뒤에 `final` 이 붙을 수 없다.
>    + final 이 붙으면 상속 자체가 불가능하여 상속하여 추상 메소드를 재정의할 수 없다.
> 2. 추상클래스가 소유한 추상메소드에는 `private, static, final` 이 붙을 수 없다.
>    + `private` 가 붙으면 서브클래스가 접근이 불가능해서 상속받아 재정의할 수 없다.
>    + `static` 이 붙으면 객체 생성 없이 `클래스명.메소드(~)` 형식으로 호출이 가능하다. 하지만 `body({~})`가 없어서 불가능하다.
> 3. 추상클래스는 객체화 할 수 없다. 추상 메소드는 호출이 불가능하기 때문이다.
> 4. 추상클래스를 상속받은 서브클래스가 추상클래스가 소유한 모든 추상메소드를 재정의하면 서브클래스는 객체화가 가능한 일반클래스가 된다.
> 5. 추상클래스를 상속받은 서브클래스가 추상클래스가 소유한 모든 추상메소드를 재정의하지 않으면 서브클래스도 추상클래스가 된다. 즉, 추상메소드가 없어도 추상클래스가 될 수 있다.
> 6. 추상 메소드도 없고 조상 클래스에서 body 가 없는 메소드를 재정의한 상태의 후손 일반클래스도 `abstract` 를 붙일 수 있다.
> 7. 객체화 금지 목적이거나 추후 body 없는 메소드를 추가하여 추상 클래스를 만들 예정일 경우 일반클래스에도 `abstract` 를 붙인다.

---

# **종단클래스**
> 다른 클래스에게 상속을 할 수 없는 클래스를 말한다.

---

## **종단클래스 형식**
```java
[public] final class 클래스명 {
    
}
```

---

## **종단클래스의 특징**
> 1. 종단클래스 이름 앞에 `abstract` 가 올 수 없다.
> 2. 상속이 불가능하므로 종단클래스가 소유한 멤버를 재정의해서 사용할 수 없다.(보안)

---

